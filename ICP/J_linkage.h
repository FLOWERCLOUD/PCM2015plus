#ifndef _J_LINKAGE_H
#define _J_LINKAGE_H

#include <vector>
#include <set>
#include <queue>
#include <algorithm>
#include <memory>

using namespace std;
/*
	Usage:

	e.g.

	struct point{
	double x;
	double y;
	};

	struct line{
	double a;
	double b;
	double c;
	};

	struct P2LDistanceFunction
	{
	typedef double DistanceType;

		P2LDistanceFunction(DistanceType l):lamda(l){}

		// Lines, whose distance from the point is larger than lamda ,are not belong to the point's  PS
		DistanceType lamda;

		DistanceType operator()( point& p, line& l )
		{
			return fabs(  l.a * p.x + l.b * p.y + l.c ) / sqrt( l.a*l.a + l.b*l.b );
		}
	};


	J_LinkageAdapter<point, line, P2LDistanceFunction>	algo_adaptor(point_data, line_data, labels, P2LDistanceFunction(0.05) );

	algo_adapter.compute();

	// point_data is std::vector<point> , which store all point data.
	// line_data is std::vector<line>, which store line data and is generated by user and pass to the adapter.
	// labels is std::vector<int>. After calling compute function, labels would store each point's cluster id. So user just need to declare labels, and pass it to the adapter.



*/
template< class  Point, class Line, class Point2LineDistance >
class J_LinkageAdapter{

protected:
	typedef		size_t		IndexType;
	typedef		double		PSDistanceType;
	typedef		typename Point2LineDistance::DistanceType		P2LDistanceType;

	struct PS
	{
		//Store Index
		set<IndexType>		which_lines;
		set<IndexType>		which_points;
		bool				is_valid;
		int					node_idx;
	};

	struct heap_node
	{
		heap_node(shared_ptr<PS>& pp1, shared_ptr<PS>& pp2 ):ps1(pp1),ps2(pp2){}

		weak_ptr<PS>		ps1;
		weak_ptr<PS>		ps2;
		PSDistanceType	dist;
	};

	struct greater_than{
		bool operator()(const heap_node& lhs, const heap_node& rhs )
		{
			return lhs.dist > rhs.dist;
		}

	};

public:
	J_LinkageAdapter( std::vector<Point>& points, std::vector<Line>& lines, std::vector<int>& labels,
								Point2LineDistance dist_func  ):point_set_(points),line_set_(lines),
								label_set_(labels),p2l_dist_func_(dist_func){  }
	~J_LinkageAdapter(){}

	void compute()
	{
		ps_init();

		/** PS Merge Procedure **/

		//Construct min-heap
		std::priority_queue< heap_node, std::vector<heap_node>,greater_than >	min_heap;
		IndexType		pn= ps_set_.size();
		for ( IndexType i=0; i < pn; i++ )
		{
			for ( IndexType j = i+1; j <pn; j++ )
			{
				heap_node	node( ps_set_[i], ps_set_[j] );
				node.dist = ps_distance( *(ps_set_[i]), *(ps_set_[j]) );
				if (node.dist==1.)
				{
					continue;
				}
				min_heap.push( node );
			}
		}

		//Begin merge
		while ( !min_heap.empty() )
		{
			heap_node min_node = min_heap.top();
			min_heap.pop();
			if (min_node.ps1.expired() || min_node.ps2.expired() )
			{
				continue;
			}
			if ( min_node.dist > 1. - 1./point_set_.size() )
			{
				break;
			}
			shared_ptr<PS> ps1 = min_node.ps1.lock();
			shared_ptr<PS> ps2 = min_node.ps2.lock();


			ps_merge( *ps1, *ps2 );


			vector< shared_ptr<PS> >::iterator new_ps_iter = ps_set_.end() - 1;
			for (vector< shared_ptr<PS> >::iterator iter = ps_set_.begin();
				iter != new_ps_iter; )
			{

				if (  (*iter)->is_valid ==false )
				{
					iter = ps_set_.erase( iter );
					new_ps_iter = ps_set_.end() - 1;
				}
				else
				{
					heap_node	node( *iter, *new_ps_iter );
					node.dist = ps_distance( *(*iter), *(*new_ps_iter) );
					if (node.dist==1.)
					{
						++iter;
						continue;
					}
					min_heap.push( node );
					++iter;
				}
			}

		}

		//Store the final label
		IndexType i=0;
		for (vector< shared_ptr<PS> >::iterator ps_iter = ps_set_.begin();
			ps_iter != ps_set_.end();
			++ps_iter,++i)
		{
			for ( set<IndexType>::iterator p_idx_iter = (*ps_iter)->which_points.begin();
				p_idx_iter != (*ps_iter)->which_points.end();
				++p_idx_iter)
			{
				label_set_[ *p_idx_iter ] = i;
			}
		}


	}

protected:

	//Init PS set
	inline void ps_init()
	{
		ps_set_.clear();
		int point_idx =0 ;
		for (vector<Point>::iterator p_iter = point_set_.begin(); p_iter!=point_set_.end(); p_iter++, point_idx++ )
		{
			ps_set_.push_back( shared_ptr<PS>(new PS) );
			PS& ps = *( ps_set_.back() );
			int line_idx = 0;
			for(vector<Line>::iterator l_iter = line_set_.begin() ; l_iter!=line_set_.end(); l_iter++,line_idx++)
			{
				if( p2l_dist_func_(*p_iter, *l_iter) < p2l_dist_func_.lamda)
					ps.which_lines.insert( line_idx );
			}
			ps.is_valid = true;
			ps.which_points.insert(point_idx);
		}
		Logger<< "ps size" <<ps_set_[0]->which_lines.size()<<endl;
	}

	//Compute Distance between PS
	PSDistanceType	ps_distance( const PS& ps1, const PS& ps2 )
	{
		set<IndexType>::iterator first1  = ps1.which_lines.begin();
		set<IndexType>::iterator last1 = ps1.which_lines.end();
		set<IndexType>::iterator first2 = ps2.which_lines.begin();
		set<IndexType>::iterator last2 = ps2.which_lines.end();

		int intersection_count = 0;

		//Count Intersection Part
		while (first1!=last1 && first2!=last2)
		{
			if ( *first1 < *first2 )++first1;
			else if ( *first1 > *first2 )++first2;
			else
			{
				intersection_count++;
				++first1;++first2;
			}
		}

		if ( intersection_count==0 )
		{
			return 1.;
		}

		int union_count = (ps1.which_lines.size() + ps2.which_lines.size() ) - intersection_count;

		double res = 1. - ( double(intersection_count) /double( union_count) );
		return res;
	}

	//Merge two PS
	void ps_merge( PS& ps1, PS& ps2  )
	{

		//merge line set
		set<IndexType>::iterator first1  = ps1.which_lines.begin();
		set<IndexType>::iterator last1 = ps1.which_lines.end();
		set<IndexType>::iterator first2 = ps2.which_lines.begin();
		set<IndexType>::iterator last2 = ps2.which_lines.end();

		ps_set_.push_back( shared_ptr<PS>(new PS) );
		PS& ps3 = *( ps_set_.back() );

		while (first1!=last1 && first2!=last2)
		{
			if ( *first1 < *first2 )++first1;
			else if ( *first1 > *first2 )++first2;
			else
			{
				ps3.which_lines.insert( *first1 );
				++first1;++first2;
			}
		}

		//merge point set
		first1  = ps1.which_points.begin();
		last1 = ps1.which_points.end();
		first2 = ps2.which_points.begin();
		last2 = ps2.which_points.end();

		while (first1!=last1)
		{
			ps3.which_points.insert( *first1 );
			++first1;
		}

		while (first2 != last2 )
		{
			ps3.which_points.insert( *first2 );
			++first2;
		}

		ps3.is_valid = true;
		ps1.is_valid = false;
		ps2.is_valid = false;



	}



protected:
	vector< Point >&							point_set_;
	vector< Line >&							line_set_;
	vector<	int	>&							label_set_;
	vector<shared_ptr<PS>>			ps_set_;
	Point2LineDistance						p2l_dist_func_;

};

#endif
